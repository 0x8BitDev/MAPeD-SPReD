//#######################################################
//
// Generated by MAPeD-PCE Copyright 2017-2022 0x8BitDev
//
//#######################################################


#incasm( "tilemap.asm" )

// export options:
//	- tiles 4x4/(columns)
//	- properties per CHR
//	- mode: bidirectional scrolling
//	- layout: adjacent screen indices (no marks)
//	- no entities


/* exported data flags: */

#define FLAG_TILES2X2                 0
#define FLAG_TILES4X4                 1
#define FLAG_RLE                      0
#define FLAG_DIR_COLUMNS              1
#define FLAG_DIR_ROWS                 0
#define FLAG_MODE_MULTIDIR_SCROLL     0
#define FLAG_MODE_BIDIR_SCROLL        1
#define FLAG_MODE_BIDIR_STAT_SCR      0
#define FLAG_MODE_STAT_SCR            0
#define FLAG_ENTITIES                 0
#define FLAG_ENTITY_SCR_COORDS        0
#define FLAG_ENTITY_MAP_COORS         0
#define FLAG_LAYOUT_ADJ_SCR           0
#define FLAG_LAYOUT_ADJ_SCR_INDS      1
#define FLAG_LAYOUT_MATRIX            0
#define FLAG_MARKS                    0
#define FLAG_PROP_ID_PER_BLOCK        0
#define FLAG_PROP_ID_PER_CHR          1

#define MAPS_CNT	1

#define BAT_INDEX	0
#define CHRS_OFFSET	32	// first CHR index from the beginning of VRAM

#define SCR_BLOCKS2x2_WIDTH	16	// number of screen blocks (2x2) in width
#define SCR_BLOCKS2x2_HEIGHT	14	// number of screen blocks (2x2) in height

#define ScrTilesWidth	8	// number of screen tiles (4x4) in width
#define ScrTilesHeight	7	// number of screen tiles (4x4) in height

#define ScrPixelsWidth	256	// screen width in pixels
#define ScrPixelsHeight	224	// screen height in pixels

/* screen data */

typedef struct
{
#if	FLAG_MODE_BIDIR_SCROLL + FLAG_MODE_STAT_SCR
	u8	chr_id;
#endif
#if	FLAG_MARKS
	//bits: 7-4 - bit mask of user defined adjacent screens ( Down(7)-Right(6)-Up(5)-Left(4) ); 3-0 - screen property
	u8	marks;
#endif
#if	FLAG_MODE_STAT_SCR
	u16	VDC_data_offset;
#endif
#if	FLAG_MODE_BIDIR_SCROLL + FLAG_MODE_STAT_SCR
	u8	scr_ind;
#endif
#if	FLAG_LAYOUT_ADJ_SCR
	// adjacent screen pointers
	void*	adj_scr[4];
#endif
#if	FLAG_LAYOUT_ADJ_SCR_INDS
	u8	adj_scr[4];
#endif
#if	FLAG_ENTITIES
	u8	ents_cnt;
	mpd_ENTITY_INSTANCE*	ents[];
#endif
} mpd_SCREEN;


extern u16*	chr0;

#asm
_mpd_CHRs:
	.word bank(_chr0)
	.word _chr0
#endasm

extern u16	mpd_CHRs[];
extern u16*	mpd_CHRs_size;
extern u8*	mpd_Props;
extern u16*	mpd_PropsOffs;
extern u8*	mpd_Tiles;
extern u16*	mpd_TilesOffs;
extern u16*	mpd_BlocksOffs;
extern u16*	mpd_Attrs;
extern u8*	mpd_TilesScr;
extern u16*	mpd_Plts;

// *** _Lev0 ***

extern mpd_SCREEN*	Lev0_ScrArr[];
extern mpd_SCREEN*	Lev0_StartScr;

#asm
_Lev0_StartScr:	.word _Lev0Scr0

_Lev0Scr0:
	.byte 0	; chr_id

	.byte 0	; screen index

; adjacent screen indices ( the valid values are $00 - $FE, $FF - means no screen )
; use the _Lev0_ScrArr array to get a screen description by adjacent screen index
	.byte $FF	; left adjacent screen index
	.byte $FF	; up adjacent screen index
	.byte $FF	; right adjacent screen index
	.byte $01	; down adjacent screen index

_Lev0Scr10:
	.byte 0

	.byte 1

	.byte $FF
	.byte $00
	.byte $FF
	.byte $05

_Lev0Scr12:
	.byte 0

	.byte 2

	.byte $FF
	.byte $FF
	.byte $03
	.byte $06

_Lev0Scr13:
	.byte 0

	.byte 3

	.byte $02
	.byte $FF
	.byte $04
	.byte $FF

_Lev0Scr14:
	.byte 0

	.byte 4

	.byte $03
	.byte $FF
	.byte $FF
	.byte $07

_Lev0Scr20:
	.byte 0

	.byte 5

	.byte $FF
	.byte $01
	.byte $FF
	.byte $08

_Lev0Scr22:
	.byte 0

	.byte 6

	.byte $FF
	.byte $02
	.byte $FF
	.byte $0A

_Lev0Scr24:
	.byte 0

	.byte 7

	.byte $FF
	.byte $04
	.byte $FF
	.byte $0B

_Lev0Scr30:
	.byte 0

	.byte 8

	.byte $FF
	.byte $05
	.byte $09
	.byte $FF

_Lev0Scr31:
	.byte 0

	.byte 9

	.byte $08
	.byte $FF
	.byte $0A
	.byte $FF

_Lev0Scr32:
	.byte 0

	.byte 10

	.byte $09
	.byte $06
	.byte $FF
	.byte $0C

_Lev0Scr34:
	.byte 0

	.byte 11

	.byte $FF
	.byte $07
	.byte $FF
	.byte $0E

_Lev0Scr42:
	.byte 0

	.byte 12

	.byte $FF
	.byte $0A
	.byte $0D
	.byte $FF

_Lev0Scr43:
	.byte 0

	.byte 13

	.byte $0C
	.byte $FF
	.byte $0E
	.byte $FF

_Lev0Scr44:
	.byte 0

	.byte 14

	.byte $0D
	.byte $0B
	.byte $0F
	.byte $FF

_Lev0Scr45:
	.byte 0

	.byte 15

	.byte $0E
	.byte $FF
	.byte $10
	.byte $FF

_Lev0Scr46:
	.byte 0

	.byte 16

	.byte $0F
	.byte $FF
	.byte $FF
	.byte $11

_Lev0Scr56:
	.byte 0

	.byte 17

	.byte $FF
	.byte $10
	.byte $FF
	.byte $12

_Lev0Scr66:
	.byte 0

	.byte 18

	.byte $FF
	.byte $11
	.byte $13
	.byte $FF

_Lev0Scr67:
	.byte 0

	.byte 19

	.byte $12
	.byte $FF
	.byte $14
	.byte $FF

_Lev0Scr68:
	.byte 0

	.byte 20

	.byte $13
	.byte $FF
	.byte $15
	.byte $FF

_Lev0Scr69:
	.byte 0

	.byte 21

	.byte $14
	.byte $FF
	.byte $FF
	.byte $FF

; screens array
_Lev0_ScrArr:
	.word _Lev0Scr0
	.word _Lev0Scr10
	.word _Lev0Scr12
	.word _Lev0Scr13
	.word _Lev0Scr14
	.word _Lev0Scr20
	.word _Lev0Scr22
	.word _Lev0Scr24
	.word _Lev0Scr30
	.word _Lev0Scr31
	.word _Lev0Scr32
	.word _Lev0Scr34
	.word _Lev0Scr42
	.word _Lev0Scr43
	.word _Lev0Scr44
	.word _Lev0Scr45
	.word _Lev0Scr46
	.word _Lev0Scr56
	.word _Lev0Scr66
	.word _Lev0Scr67
	.word _Lev0Scr68
	.word _Lev0Scr69

#endasm

extern mpd_SCREEN** mpd_MapsArr[];

#asm
_mpd_MapsArr:
	.word _Lev0_StartScr

#endasm

extern mpd_SCREEN** mpd_MapsScrArr[];

#asm
_mpd_MapsScrArr:
	.word _Lev0_ScrArr

#endasm
